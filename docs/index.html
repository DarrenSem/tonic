<html>
  <head>
    <meta charset="utf-8">
    <title>Tonic: Component Based Architecture</title>
    <link href="https://fonts.googleapis.com/css?family=EB+Garamond|Source+Code+Pro:500,700" rel="stylesheet">
    <link href="index.css" rel="stylesheet">
  </head>

  <body>
    <div class="back"></div>

    <main>
      <div class="wrapper">
        <img class="accent" src="drink.svg" width="150">
        <img src="tonic.svg" width="200">
        <p class="center large">
          <i>A little class for mixing behavior, layout, and style.</i>
        </p>

        <div class="row">
          <div class="col">
            <ul>
              <li>Qucikly read and understand the whole module, ~100 lines.</li>
              <li>React-like component composition.</li>
              <li>One-way binding. Pipe data though connected components.</li>
            </ul>
          </div>
          <div class="col">
            <ul>
              <li>Evented, single source dispatch. No event rebinding.</li>
              <li>Routing agnostic (not all UIs are intended to run in a browser).</li>
              <li>Async or sync, server and client side rendering.</li>           
            </ul>
          </div>
        </div>

        <p class="center">An (incomplete) example component.</p>
        <pre><code>
class Box extends Tonic {
  <i>//
  // You can listen to any dom event by creating a method with
  // the corresponding name. The method will receive the plain
  // old Javascript event object.
  //</i>
  mouseover (e) {
    e.target.style.backgroundColor = someRandomColor
  }

  <i>// 
  // If you wanted, you could test if the event target
  // clicked matches a selector by using <b>Tonic.match()</b>.
  //</i>
  mouseout (e) {
    if (!Tonic.match(e.target, '.box')) return

    e.target.style.backgroundColor = '#fff'
  }

  <i>//
  // Render <b>must return one root element</b> (which can contain as
  // many elements as you want). The root must have <b>${this.id}</b>
  // if you want to listen to dom or lifecycle events.
  //</i>
  render (props) {
    return `
      &lt;div ${this.id} class="box"&gt; 
        Box (${props.n})
      &lt;/div&gt;
    `
  }
}

const box = new Box()</code>

</pre>

        <p class="center">
          Another component that uses the instance of the <b>box</b> component.
        </p>
        <pre><code>
class BoxContainer extends Tonic {
  <i>//
  // A constructor is not required.
  //</i>
  constructor (props) {
    super(props)

    <i>//
    // One way of adding styles (check the render function
    // for how it's used). Since it's just a string it could
    // be rendered into a style tag and could even be read-in
    // from a separate file.
    //</i>
    this.style = `
      border: 1px solid blue;
      height: 200px;
      width: 200px;
    `
  }

  <i>//
  // The <b>mount</b> event is fired once the root element is attached
  // to the dom.
  //</i>
  mount (el) {
    console.log('Mounted! The dom node is ready to use.')
  }

  <i>//
  // The <b>root dom node</b> of the component can be accessed from
  // <b>this.el</b> after the component has been mounted.
  //</i>
  show () {
    this.el.classList.add('show')
  }

  click (e) {
    <i>//
    // Set state on a component instance or on this instance,
    // <b>setProps()</b> will cause a downward cascade of re-rendering.
    //</i>
    box.setProps({ n: someRandomString })
  }

  <i>//
  // Render will return a string. It can be an <b>async</b> function,
  // if it is, it can be awaited (don't forget to <b>await</b> the
  // <b>attach</b> method).
  //</i>
  render (props) {
    return `
      &lt;div ${this.id} style="${this.style}"&gt;
        Box Container ${box.render(props)}
      &lt;/div&gt;
    `
  }
}</code>

</pre>

        <p class="center">Components can be attached to any node.</p>
        <pre><code>
<i>//
// Your app may create and attach one or more components
// to any node at any time.
//</i>
const container = new BoxContainer({ n: 100 })
container.attach(document.body)</code>

</pre>

        <p class="center">Demo (click and hover).</p>
        <div id="demo"></div>

        <p class="center">Rendering from a server.</p>
        <pre><code>
http.createServer((req, res) => {
  const container = new BoxContainer({ n: 100 })
  res.end(container.render())
})</code>

</pre>

        <p class="center">Questions &amp; Answers.</p>
        <pre><code>
<b>Q. Is this a framework?</b>
A. No. But it can be used with one.

<b>Q. My framework has modules, what about those?</b>
A. Why not use something who's singular purpose is to
   handle linking and compiling modules? For example,
   Browserify, Webpack, or even the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">web</a>.

<b>Q. What about routing?</b>
A. There are lots of routers to choose from.

<b>Q. How fast is this?</b>
A. Fast enough. If you need something faster you don't
   need a component class. Either manage some of the
   nodes directly or use a graphics/animation engine.

<b>Q. Can I use this in production?</b>
A. If you need to ask, the answer is no.

</code>
</pre>
      </div>

      <p class="center">More details on <a href="https://github.com/hxoht/tonic">Github</a></p>
    </main>
    <script src="bundle.js"></script>
  </body>
</html>
